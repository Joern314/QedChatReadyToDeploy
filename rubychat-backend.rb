require 'dbi'
require 'json'
require './rubychat-config.rb'

#This class provides methodes to interface with the chat-db.
class ChatBackend
    #TODO: Think about locking
    #@@dbMutex = Mutex.new

    #Inserts a new post into db
    def createPost(name, message, channel, date, user_id, delay, bottag, public_id)
        sql = "INSERT INTO content2 (name, message, channel, date, user_id, delay, bottag, publicid) " +
		    "VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
	    chatDatabase {|db| db.do(sql, name, message, channel, date, user_id, delay, bottag, public_id)}
    end

    #Verifies the credentials
    # @return [Hash] Username and password if sucessful, nil if not
    def userAuthenticate(username, password)
	    sql = "SELECT id, password FROM user WHERE username=? AND password=SHA1(CONCAT(username, ?))"
	    chatDatabase {|db| 
            row = db.select_one(sql, username, password)
            return row.nil? ? nil : row.to_h
        }
    end

    #Verifies the cookie
    # @return [Integer] The uid if sucessful, nil if not
    def checkCookie(user_id, pwhash)
        sql = "SELECT id FROM user WHERE id=? AND password=?"
        chatDatabase {|db|
		    row = db.select_one(sql, user_id, pwhash)
            return row.nil? ? nil : row['id'].to_i
        }
    end

    #Gets the id of current post - offset
    def getCurrentId(channel, offset)
        sql = "SELECT id + 1 AS from_id FROM content2 WHERE channel = ? ORDER BY id DESC LIMIT ?, 1"
		chatDatabase {|db| 
            row = db.select_one(sql, channel, offset)
			return row.nil? ? 0 : row['from_id']
        }
    end

    #Gets the id of the last post generated by a certain user
    def getLastPostId(channel, uid)
        sql = "SELECT MAX(id) AS from_id FROM content2 WHERE channel = ? AND user_id = ?"
        chatDatabase {|db|
            row = db.select_one(sql, channel, uid)
            return row.nil? ? 0: row['from_id']
        }
    end

    SqlPostTemplate = "SELECT content2.id AS id, name, message, channel, DATE_FORMAT(date, '%Y-%m-%d %H:%i:%s') AS date, user_id, delay, bottag, publicid, username " +
		"FROM content2 LEFT JOIN user ON content2.user_id=user.id "
        
    #Gets all posts in a channel starting with id, orederd asc by id
    #Callback gets executed for each row
    def getPostsByStartId(channel, id, limit = 0, &callback)
        sql = SqlPostTemplate + "WHERE content2.id >= ? AND channel = ? ORDER BY id"
        if limit == 0
            chatDatabase {|db| db.select_all(sql, id, channel, &callback)}
        else
            sql += " LIMIT ?"
            chatDatabase {|db| db.select_all(sql, id, channel, limit, &callback)}    
        end
    end
    
    def getPostsByIdInterval(channel, startId, endId, &callback)
        sql = SqlPostTemplate + "WHERE channel = ? AND content2.id >= ? AND content2.id <= ? ORDER BY id"
        chatDatabase {|db| db.select_all(sql, channel, startId, endId, &callback)}
    end

    def getPostsByDateInterval(channel, startDate, endDate, &callback)
        sql = SqlPostTemplate + "WHERE channel = ? AND date >= ? AND date <= ? ORDER BY id"
		chatDatabase {|db| db.select_all(sql, channel, startDate, endDate, &callback)}
    end

    def getPostsByStartDate(channel, startDate, &callback)
        sql = SqlPostTemplate + "WHERE channel = ? AND date >= ? ORDER BY id"
        chatDatabase {|db| db.select_all(sql, channel, startDate.strftime("%F %X"), &callback)}
    end
    
    def formatAsJson(posting)
        posting.each {|k, v| posting[k] = v.force_encoding('UTF-8') if v.class == String}
        if not posting['publicid'] then
		    posting['username']=nil
		    posting['user_id']=nil
	    elsif not posting['username'] then
		    posting['username']='?'
	    end
	    posting.delete('publicid')
        posting.merge!({'type' => 'post', 'color' => colorForName(posting['name'])})
        posting.to_json
    end

    private

    def colorForName(name)
        md5 = Digest::MD5.new
        r = md5.hexdigest('a' + name + 'a')[-7..-1].to_i(16) % 156 + 100
        g = md5.hexdigest('b' + name + 'b')[-7..-1].to_i(16) % 156 + 100
        b = md5.hexdigest('c' + name + 'c')[-7..-1].to_i(16) % 156 + 100
        r.to_s(16) + g.to_s(16) + b.to_s(16)
    end

    #Create a new connection for each query to avoid connection timeouts
    def chatDatabase
	    DBI.connect($sqlDatabase, $sqlUsername, $sqlPassword) {|db|
		    db.do("SET NAMES UTF8mb4")
            yield(db)
            db.disconnect()
        }
    end
end
